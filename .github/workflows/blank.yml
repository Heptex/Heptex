name: Extract Proprietary Blobs

on:
  workflow_dispatch:
    inputs:
      firmware_drive_link:
        description: "Google Drive link to firmware ZIP"
        required: true
        default: "https://drive.google.com/file/d/<file-id>/view?usp=sharing"

jobs:
  extract-and-upload:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Install gdown for Google Drive downloads
      - name: Install gdown
        run: |
          sudo apt-get update
          sudo apt-get install -y python3 python3-pip
          pip install gdown

      # Step 2: Download firmware from Google Drive
      - name: Download Firmware ZIP from Google Drive
        run: |
          mkdir -p firmware
          # Extract file ID from Google Drive link
          file_id=$(echo "${{ github.event.inputs.firmware_drive_link }}" | grep -o 'd/[^/]*' | cut -d'/' -f2)
          gdown "https://drive.google.com/uc?id=$file_id" -O firmware/firmware.zip

      # Step 3: Install required tools
      - name: Install Required Tools
        run: |
          sudo apt-get update
          sudo apt-get install -y unzip simg2img mount tar curl jq e2fsprogs f2fs-tools

      # Step 4: Unzip the firmware file
      - name: Unzip Firmware
        run: |
          unzip firmware/firmware.zip -d firmware

      # Step 5: Extract Blobs from Specific Partitions
      - name: Extract Proprietary Blobs
        run: |
          mkdir -p mount_points blobs
          
          # Define partitions of interest
          partitions="vendor firmware odm product modem system"

          # Process each partition
          for part in $partitions; do
            img_file=$(find firmware -name "$part.img" || true)

            if [ -z "$img_file" ]; then
              echo "Partition $part.img not found, skipping."
              continue
            fi

            echo "Processing $img_file"

            # Convert sparse to raw if needed
            if file "$img_file" | grep -q "sparse"; then
              raw_img="mount_points/${part}.raw"
              simg2img "$img_file" "$raw_img"
            else
              raw_img="$img_file"
            fi

            # Check and repair filesystem if necessary
            sudo fsck -y "$raw_img" || true

            # Mount the raw image
            mkdir -p mount_points/$part
            if ! sudo mount -o loop "$raw_img" mount_points/$part; then
              echo "Failed to mount $raw_img. Skipping."
              continue
            fi

            # Copy blobs to the output directory
            cp -r mount_points/$part/* blobs/ || true

            # Unmount and clean up
            sudo umount mount_points/$part
            rm -rf mount_points/$part
          done

      # Step 6: Archive the extracted blobs
      - name: Archive Extracted Blobs
        run: |
          tar -czvf blobs.tar.gz blobs

      # Step 7: Upload to GoFile
      - name: Upload to GoFile
        run: |
          # Check if file argument is provided
          if [[ "$#" == '0' ]]; then
              echo -e 'ERROR: No File Specified!' && exit 1
          fi

          # Store the file path, preserving spaces
          FILE="blobs.tar.gz"

          # Query GoFile API to find the best server for upload
          SERVER=$(curl -s https://api.gofile.io/servers | jq -r '.data.servers[0].name')

          # Upload the file to GoFile
          LINK=$(curl -# -F "file=@$FILE" "https://${SERVER}.gofile.io/uploadFile" | jq -r '.data|.downloadPage') 2>&1

          # Display the download link
          echo "$LINK"

          # Print a blank line for better readability
          echoq
